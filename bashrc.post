export CUDA_ROOT=/usr/local/cuda
export PATH="$CUDA_ROOT/bin:$PATH"
export LD_LIBRARY_PATH="$CUDA_ROOT/lib:$LD_LIBRARY_PATH"

export DEBFULLNAME="Sergey Ivanov"
export DEBEMAIL="seiv@yandex-team.ru"
alias dch='dch --distributor=debian'

# prompt
git_branch_name() {
    branch=$(git branch 2>/dev/null | grep '^\* ' | cut -c3-)
    if [ "$branch" ]; then
        echo -n ' ('$branch')'
    fi
}

hg_dirty() {
    dirty=$(hg status 2> /dev/null | awk '$1 == "?" { unknown = 1 }
           $1 != "?" { changed = 1 }
           END {
             if (changed) printf "!"
             else if (unknown) printf "?"
             }')
    if [ "$dirty" ]; then
        echo -n " ($dirty)"
    else
        echo -n " üó∏"
    fi
}

hg_book() {
    # hg branch 2> /dev/null | \
    #     awk '{ printf "\033[37;0m on \033[35;40m" $1 }'
    book=$(hg bookmarks 2> /dev/null | awk '/\*/ { printf $2 }')
    if [ "$book" ]; then
        echo -n " @$book"
    fi
}

DEFAULT="[37;40m"
PINK="[35;40m"
BLUE="[34;40m"
GREEN="[32;40m"
ORANGE="[33;40m"
RED="[31;40m"

# export PS1='\n\
# \e${BLUE}\u\
# \e${PINK}@\
# \e${BLUE}\H\
# \e${GREEN} \
# \e${GREEN}\w\
# \e${GREEN}\
# \e${ORANGE}\
# $(git_branch_name) \
# $(hg_book) \
# $(hg_dirty) \
# \e${GREEN}\n\
# \e${RED}\$\
# \[\e[00m\]'


# export PS1='\n\[\e[0;34m\]\u\[\e[0;35m\]@\[\e[0;34m\]\H\[\e[0;32m\] \[\e[0;32m\]\w\[\e[0;32m\]\[\e[0;33m\]$(git_branch_name)\[\e[0;32m\]\n\[\e[0;31m\]\$\[\e[00m\]'
# export PS1='\n\u at \h in \w $(hg_in_repo)$(hg_book)$(hg_dirty)\n$ '

export PS1='\n\[\e[0;34m\]\u\[\e[0;35m\]@\[\e[0;34m\]\H\[\e[0;32m\] \[\e[0;32m\]\w\[\e[0;32m\]\[\e[0;33m\]$(git_branch_name)$(hg_book)$(hg_dirty)\[\e[0;00m\]\n\[\e[0;31m\]\$\[\e[00m\]'

# \[\e[A;B;Cm\], –≥–¥–µ
# A - —Ç–∏–ø —à—Ä–∏—Ñ—Ç–∞:
# 0 - –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é; 1 - —è—Ä–∫–∏–π (–∂–∏—Ä–Ω—ã–π); 4 - –ø–æ–¥—á–µ—Ä–∫–Ω—É—Ç—ã–π; 5 - –º–∏–≥–∞—é—â–∏–π.
# B - —Ü–≤–µ—Ç —Ç–µ–∫—Å—Ç–∞:
# 30 - —á–µ—Ä–Ω—ã–π; 31 - –∫—Ä–∞—Å–Ω—ã–π; 32 - –∑–µ–ª–µ–Ω—ã–π; 33 - –∂–µ–ª—Ç—ã–π; 34 - —Å–∏–Ω–∏–π; 35 - —Ä–æ–∑–æ–≤—ã–π; 36 - –±–∏—Ä—é–∑–æ–≤—ã–π; 37 - –±–µ–ª—ã–π.
# C - —Ü–≤–µ—Ç —Ñ–æ–Ω–∞:
# 40 - —á–µ—Ä–Ω—ã–π; 41 - –∫—Ä–∞—Å–Ω—ã–π; 42 - –∑–µ–ª–µ–Ω—ã–π; 43 - –∂–µ–ª—Ç—ã–π; 44 - —Å–∏–Ω–∏–π; 45 - —Ä–æ–∑–æ–≤—ã–π; 46 - –±–∏—Ä—é–∑–æ–≤—ã–π; 47 - –±–µ–ª—ã–π.

# \A  the current time in 24-hour HH:MM format
# \D{format}  the format is passed to strftime(3) and the result is inserted into the prompt string; an empty format results in a locale-specific time representation. The braces are required
# \H  the hostname
# \T  the current time in 12-hour HH:MM:SS format
# \V  the release of bash, version + patch level (e.g., 2.00.0)
# \W  the basename of the current working directory, with $HOME abbreviated with a tilde
# \a  an ASCII bell character (07)
# \d  the date in "Weekday Month Date" format (e.g., "Tue May 26")
# \e  an ASCII escape character (033)
# \h  the hostname up to the first ‚Äò.‚Äô
# \j  the number of jobs currently managed by the shell
# \l  the basename of the shell‚Äôs terminal device name

# \!  the history number of this command
# \#  the command number of this command
# \$  if the effective UID is 0, a #, otherwise a $
# \@  the current time in 12-hour am/pm format
# \[  begin a sequence of non-printing characters, which could be used to embed a terminal control sequence into the prompt
# \\  a backslash
# \]  end a sequence of non-printing characters
# \n  newline
# \nnn    the character corresponding to the octal number nnn
# \r  carriage return
# \s  the name of the shell, the basename of $0 (the portion following the final slash)
# \t  the current time in 24-hour HH:MM:SS format
# \u  the username of the current user
# \v  the version of bash (e.g., 2.00)
# \w  the current working directory, with $HOME abbreviated with a tilde

export LC_ALL="en_US.UTF-8"
export LANG="ru.UTF-8"

export CLICOLOR=1
export LSCOLORS=Gxfxcxdxbxegedabagacad
export EDITOR=vim

stty stop ''

